C51 COMPILER V9.60.7.0   IR_RX                                                             08/14/2025 11:44:06 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE IR_RX
OBJECT MODULE PLACED IN .\Objects\ir_rx.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ir_rx.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Include;..\..\My_Lib
                    -raries\2 Wire LCD  (Software Delay);..\..\My_Libraries\Software Delay;..\..\Include) DEFINE(FOSC_160000) DEBUG OBJECTEXT
                    -END PRINT(.\Listings\ir_rx.lst) TABS(2) OBJECT(.\Objects\ir_rx.obj)

line level    source

   1          /*
   2           *  @author:  MinhHieuEC
   3           *  @date:    30/11/2019
   4           */
   5          #include "ir_rx.h"
   6          
   7          #define delay_ms(x) Timer2_Delay500us(x * 2)
   8          #define debug printf
   9          
  10          #define sync_high 17000 // 22000 Ã 0.75ms = 16.5ms
  11          #define sync_low 12000  // 14000 Ã 0.75ms = 10.5ms
  12          #define one_high 3600   // 3600 Ã 0.75ms = 2.7ms
  13          #define one_low 2000    // 2400 Ã 0.75ms = 1.8ms
  14          #define zero_high 1800  // 1800 Ã 0.75ms = 1.35ms
  15          #define zero_low 800    // 1200 Ã 0.75ms = 0.9ms
  16          
  17          //  1: start ir byte + IR_DATA_NUM_BYTES*8 bytes data
  18          #define IR_RECEIVE_BYTE ((IR_DATA_LEN * 8) + 1)
  19          
  20          bit is_ir_received = 0;
  21          unsigned char bits = 0;
  22          unsigned int frames[IR_RECEIVE_BYTE] = {0};
  23          
  24          bit is_ir_start = 0;
  25          
  26          uint8_t ir_receiver_type = IR_USE_EXT1_IT;
  27          
  28          static void set_Timer_0(unsigned int value)
  29          {
  30   1        TH0 = ((value && 0xFF00) >> 8);
  31   1        TL0 = (value & 0x00FF);
  32   1      }
  33          
  34          static unsigned int get_Timer_0(void)
  35          {
  36   1        unsigned int value = 0x0000;
  37   1      
  38   1        value = TH0;
  39   1        value <<= 8;
  40   1        value |= TL0;
  41   1      
  42   1        return value;
  43   1      }
  44          
  45          static void erase_frames(void)
  46          {
  47   1        for (bits = 0; bits < IR_RECEIVE_BYTE; bits++)
  48   1        {
  49   2          frames[bits] = 0;
  50   2        }
  51   1      
  52   1        set_Timer_0(0x0000);
  53   1        is_ir_received = 0;
C51 COMPILER V9.60.7.0   IR_RX                                                             08/14/2025 11:44:06 PAGE 2   

  54   1        bits = 0;
  55   1        is_ir_start = 0;
  56   1      }
  57          
  58          void EXTI1_ISR(void) interrupt 2
  59          {
  60   1        frames[bits] = get_Timer_0();
  61   1      
  62   1        // detect start
  63   1        if (frames[bits] > 17000 && frames[bits] < 20000)
  64   1          is_ir_start = 1;
  65   1      
  66   1        if (is_ir_start)
  67   1          bits++;
  68   1      
  69   1        set_Timer_0(0x0000);
  70   1        set_TR0;
  71   1      
  72   1        //  frame error detect
  73   1        if (frames[bits] < 0)
  74   1        {
  75   2          is_ir_start = 0;
  76   2          bits = 0;
  77   2        }
  78   1      
  79   1        if (bits >= IR_RECEIVE_BYTE)
  80   1        {
  81   2          is_ir_received = 1;
  82   2          clr_EA;
  83   2          clr_TR0;
  84   2        }
  85   1      }
  86          
  87          void PinInterrupt_ISR(void) interrupt 7
  88          {
  89   1        if (PIF == 0x20)
  90   1        {
  91   2          frames[bits] = get_Timer_0();
  92   2      
  93   2          // detect start
  94   2          if (frames[bits] > 17000 && frames[bits] < 20000)
  95   2            is_ir_start = 1;
  96   2      
  97   2          if (is_ir_start)
  98   2            bits++;
  99   2      
 100   2          set_Timer_0(0x0000);
 101   2          set_TR0;
 102   2      
 103   2          //  frame error detect
 104   2          if (frames[bits] < 0)
 105   2          {
 106   3            is_ir_start = 0;
 107   3            bits = 0;
 108   3          }
 109   2      
 110   2          if (bits >= IR_RECEIVE_BYTE)
 111   2          {
 112   3            is_ir_received = 1;
 113   3            clr_EA;
 114   3            clr_TR0;
 115   3          }
C51 COMPILER V9.60.7.0   IR_RX                                                             08/14/2025 11:44:06 PAGE 3   

 116   2      
 117   2          PIF = 0x00; //clear interrupt flag
 118   2        }
 119   1      }
 120          
 121          /*
 122          * @brief: setup necessary things for read IR data
 123          * - setup timer0 mode 1
 124          *   timer_tick = 12/16MHz = 0.75us
 125          * - setup INT1 and enable all interrupt
 126          * - if use IR_USE_PIN_IT, please set pin is input_mode,
 127          */
 128          void ir_rx_setup(IR_Type_t ir_type)
 129          {
 130   1        erase_frames();
 131   1        TIMER0_MODE1_ENABLE;
 132   1        set_Timer_0(0x0000);
 133   1      
 134   1        switch (ir_type)
 135   1        {
 136   2        case IR_USE_EXT1_IT:
 137   2          set_IT1; // falling edge triggered
 138   2          set_EX1; // Interrupt generated by pin (P1.7) Enabled.
 139   2          break;
 140   2      
 141   2        case IR_USE_PIN_IT:
 142   2          set_EPI; // Enable pin interrupt
 143   2          break;
 144   2      
 145   2        default:
 146   2          break;
 147   2        }
 148   1      
 149   1        set_EA; // global enable bit
 150   1      }
 151          
 152          static unsigned char decode(unsigned char start_pos, unsigned char end_pos)
 153          {
 154   1        unsigned char value = 0;
 155   1      
 156   1        for (bits = start_pos; bits <= end_pos; bits++)
 157   1        {
 158   2          value <<= 1;
 159   2      
 160   2          if ((frames[bits] >= one_low) && (frames[bits] <= one_high))
 161   2          {
 162   3            value |= 1;
 163   3          }
 164   2      
 165   2          else if ((frames[bits] >= zero_low) && (frames[bits] <= zero_high))
 166   2          {
 167   3            value |= 0;
 168   3          }
 169   2      
 170   2          else if ((frames[bits] >= sync_low) && (frames[bits] <= sync_high))
 171   2          {
 172   3            return 0xFF;
 173   3          }
 174   2        }
 175   1      
 176   1        return value;
 177   1      }
C51 COMPILER V9.60.7.0   IR_RX                                                             08/14/2025 11:44:06 PAGE 4   

 178          
 179          uint8_t is_ir_data_received(void) { return is_ir_received; }
 180          
 181          void get_ir_data(uint8_t *buf, uint8_t len)
 182          {
 183   1        uint8_t cnt;
 184   1        uint8_t idx = 0;
 185   1      
 186   1        for (cnt = 0; cnt < len * 8; cnt += 8)
 187   1        {
 188   2          buf[idx] = decode(cnt + 1, cnt + 8);
 189   2          idx++;
 190   2        }
 191   1      
 192   1        delay_ms(1);
 193   1      
 194   1        erase_frames();
 195   1        set_EA; //  enable all interrupt
 196   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    709    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     68       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
